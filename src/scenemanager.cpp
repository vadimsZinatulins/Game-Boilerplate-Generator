#include "scenemanager.h"
#include "utils.h"

void generateSceneManagerHeader()
{
	mkfile("include/BE/IScene.h", {
			"#pragma once",
			"",
			"struct SDL_Renderer;",
			"",
			"namespace BE",
			"{",
			"",
			"struct IScene",
			"{",
			"	IScene() = default;",
			"	virtual ~IScene() = default;",
			"",
			"	virtual void initialize() = 0;",
			"	virtual void shutdown() = 0;",
			"",
			"	virtual void update() = 0;",
			"	virtual void render(SDL_Renderer *renderer) = 0;",
			"};",
			"}"
	});

	mkfile("include/BE/SceneManager.h", {
			"#pragma once",
			"",
			"#include \"IScene.h\"",
			"",
			"#include <stack>",
			"#include <vector>",
			"",
			"namespace BE",
			"{",
			"",
			"class SceneManager",
			"{",
			"public:",
			"	static SceneManager &getInstance();",
			"",
			"	template<typename T>",
			"	void pushScene()",
			"	{",
			"		m_scenesToAdd.push_back(new T());",
			"	}",
			"",
			"	template<typename T>",
			"	void swap()",
			"	{",
			"		popScene();",
			"		pushScene<T>();",
			"	}",
			"",
			"	void popScene();",
			"	void popAllScenes();",
			"private:",
			"	template<typename T>",
			"	friend class Game;",
			"",
			"	SceneManager() = default;",
			"	~SceneManager() = default;",
			"",
			"	void updateState();",
			"",
			"	IScene *getActiveScene() const;",
			"",
			"	std::stack<IScene*> m_scenes;",
			"",
			"	std::vector<IScene*> m_scenesToAdd;",
			"	std::vector<IScene*> m_scenesToFree;",
			"};",
			"}"
	});
}

void generateSceneManagerSource()
{
	mkfile("src/BE/SceneManager.cpp", {
		"#include \"BE/SceneManager.h\"",
		"",
		"namespace BE",
		"{",
		"",
		"SceneManager &SceneManager::getInstance()",
		"{",
		"	static SceneManager instance;",
		"	return instance;",
		"}",
		"",
		"void SceneManager::popScene()",
		"{",
		"	if(m_scenes.size() > 0)",
		"	{",
		"		m_scenesToFree.push_back(m_scenes.top());",
		"		m_scenes.pop();",
		"	}",
		"}",
		"",
		"void SceneManager::popAllScenes()",
		"{",
		"	while(m_scenes.size() > 0)",
		"	{",
		"		m_scenesToFree.push_back(m_scenes.top());",
		"		m_scenes.pop();",
		"	}",
		"}",
		"",
		"IScene *SceneManager::getActiveScene() const",
		"{",
		"	if(m_scenes.size() > 0)",
		"		return m_scenes.top();",
		"",
		"	return nullptr;",
		"}",
		"",
		"void SceneManager::updateState()",
		"{",
		"	for(IScene *scene : m_scenesToAdd)",
		"	{",
		"		scene->initialize();",
		"		m_scenes.push(scene);",
		"	}",
		"",
		"	for(IScene *scene : m_scenesToFree)",
		"	{",
		"		scene->shutdown();",
		"		delete scene;",
		"	}",
		"",
		"	m_scenesToAdd.clear();",
		"	m_scenesToFree.clear();",
		"}",
		"",
		"}",
	});
}

void generateSceneManager()
{
	generateSceneManagerHeader();
	generateSceneManagerSource();
}
